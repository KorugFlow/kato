from .codegen import ExpressionCodegen, StatementCodegen, FunctionCodegen


class CCompiler:
    def __init__(self, ast, stdlib_imports=None, c_imports=None):
        self.ast = ast
        self.indent_level = 0
        self.variables = {}
        self.stdlib_imports = stdlib_imports or set()
        self.c_imports = c_imports or set()
        self.uses_conversion = False
        self.uses_find = False
        self.function_return_types = {}
        self.struct_definitions = {}
        
        self.expr_codegen = ExpressionCodegen(self)
        self.stmt_codegen = StatementCodegen(self, self.expr_codegen)
        self.func_codegen = FunctionCodegen(self, self.stmt_codegen)
    
    def indent(self):
        return "    " * self.indent_level
    
    def get_function_return_type(self, func_name):
        return self.function_return_types.get(func_name, "int")
    
    def compile(self):
        from parser.ast import FindCall
        
        if hasattr(self.ast, 'c_imports'):
            for c_import in self.ast.c_imports:
                self.c_imports.add(c_import.header_name)
        
        def check_for_find(obj):
            if isinstance(obj, FindCall):
                self.uses_find = True
            elif hasattr(obj, '__dict__'):
                for value in obj.__dict__.values():
                    if isinstance(value, list):
                        for item in value:
                            check_for_find(item)
                    else:
                        check_for_find(value)
        
        for function in self.ast.functions:
            check_for_find(function)
        
        if hasattr(self.ast, 'structs'):
            for struct in self.ast.structs:
                self.struct_definitions[struct.name] = struct.fields
        
        for function in self.ast.functions:
            if function.params:
                function.param_types = self.func_codegen.infer_param_types(function, self.ast)
            function.return_type = self.func_codegen.infer_return_type(function)
            self.function_return_types[function.name] = function.return_type
        
        c_code = "/* WARNING: This file is auto-generated by Kato compiler.\n"
        c_code += " * Do not modify this file manually.\n"
        c_code += " * Any changes will be overwritten on next compilation.\n"
        c_code += " */\n\n"
        c_code += "#include <stdio.h>\n"
        c_code += "#include <string.h>\n"
        c_code += "#include <stdlib.h>\n"
        c_code += "#include <time.h>\n"
        
        if "os" in self.stdlib_imports:
            c_code += "#include <windows.h>\n"
            c_code += "#include <tlhelp32.h>\n"
            c_code += "#include <psapi.h>\n"
            c_code += "#include <shellapi.h>\n"
            c_code += "#include <tlhelp32.h>\n"
        
        for c_header in self.c_imports:
            c_code += f"#include <{c_header}>\n"
        
        c_code += "\n"
        
        if hasattr(self.ast, 'structs'):
            for struct in self.ast.structs:
                c_code += f"typedef struct {{\n"
                for field_name, field_type in struct.fields.items():
                    c_type = {"int": "int", "float": "float", "char": "char", "string": "char*"}[field_type]
                    c_code += f"    {c_type} {field_name};\n"
                c_code += f"}} {struct.name};\n\n"
        
        if self.uses_find:
            c_code += "int kato_find(void* target, void* pattern);\n\n"
        
        if "filesystem" in self.stdlib_imports:
            from .std.filesystem import get_filesystem_functions
            c_code += get_filesystem_functions() + "\n"
        
        if "os" in self.stdlib_imports:
            from .std.os import get_os_functions
            c_code += get_os_functions() + "\n"
        
        for function in self.ast.functions:
            if function.name != "main":
                c_code += self.func_codegen.get_function_signature(function) + ";\n"
        
        c_code += "\n"
        
        for function in self.ast.functions:
            c_code += self.func_codegen.compile_function(function)
            c_code += "\n"
        
        if self.uses_find:
            c_code += "int kato_find(void* target, void* pattern) {\n"
            c_code += "    char* t = (char*)target;\n"
            c_code += "    char* p = (char*)pattern;\n"
            c_code += "    if (!t || !p) return -1;\n"
            c_code += "    int t_len = 0, p_len = 0;\n"
            c_code += "    while (t[t_len]) t_len++;\n"
            c_code += "    while (p[p_len]) p_len++;\n"
            c_code += "    if (p_len == 0) return 0;\n"
            c_code += "    for (int i = 0; i <= t_len - p_len; i++) {\n"
            c_code += "        int match = 1;\n"
            c_code += "        for (int j = 0; j < p_len; j++) {\n"
            c_code += "            if (t[i + j] != p[j]) {\n"
            c_code += "                match = 0;\n"
            c_code += "                break;\n"
            c_code += "            }\n"
            c_code += "        }\n"
            c_code += "        if (match) return i;\n"
            c_code += "    }\n"
            c_code += "    return -1;\n"
            c_code += "}\n\n"
        
        return c_code
